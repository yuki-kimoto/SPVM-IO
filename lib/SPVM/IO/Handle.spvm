class IO::Handle {
  use Sys::IO;
  use Fn;
  use Format;
  use Scope::Guard;

  use IO::File;
  
  has autoflush : rw byte;
  has input_line_number : ro int;
  
  interface IO::Handle::Interface;
  
  # Class methods
  static method new : IO::Handle () {
    my $self = new IO::Handle;
    
    $self->init();
    
    return $self;
  }
  
  static method new_from_fd : IO::Handle ($fd : int, $mode = 0666 : int) {
    
  }

  method has_interfaces : int () { return 1; }
  
  method init : void () {
    
  }
  
  method close : int () {
    return $self->(IO::Handle::Interface)->close;
  }

  method eof : int () {
    return $self->(IO::Handle::Interface)->eof;
  }

  method fileno : int () {
    return $self->(IO::Handle::Interface)->fileno;
  }

  method getc : int () {
    return $self->(IO::Handle::Interface)->getc;
  }

  method print : int ($string : string) {
    return $self->(IO::Handle::Interface)->print($string);
  }

  method printf : int ($format : string, $args : object[]...) {
    my $formated_string = Format->sprintf($format, $args);
    return $self->print($formated_string);
  }

  method clearerr : void () {
    $self->(IO::Handle::Interface)->clearerr;
  }
  
  method error : int () {
    $self->(IO::Handle::Interface)->error;
  }

  method flush : int () {
    $self->(IO::Handle::Interface)->flush;
  }

  method ungetc : int ($c : int) {
    return $self->(IO::Handle::Interface)->ungetc($c);
  }

  method printflush : int ($string : string) {
    my $old_autoflush = $self->autoflush;
    
    # Restores the autoflush field at the end of the scope.
    my $handle = $self;
    my $scope_guard = Scope::Guard->new([$handle : IO::Handle, $old_autoflush : byte] method : void () {
      $handle->set_autoflush($old_autoflush);
    });
    
    $self->set_autoflush(1);
    $self->print($string);
  }

  method truncate : int ($legnth : long) {
    my $fileno = $self->fileno;
    
    return IO::File->ftruncate($fileno, $legnth);
  }
  
  method ioctl : int ($request : int, $request_arg = undef : object of Byte|Short|Int|Long|Float|Double|object) {
    my $fileno = $self->fileno;
    
    return Sys::Ioctl->ioctl($fileno, $request, $request_arg);
  }

  method sync : int () {
    my $fileno = $self->fileno;
    
    return IO::File->fsync($fileno);
  }
}

=pod TODO

new ()
Creates a new IO::Handle object.

new_from_fd ( FD, MODE )
Creates an IO::Handle like new does. It requires two parameters, which are passed to the method fdopen; if the fdopen fails, the object is destroyed. Otherwise, it is returned to the caller.


*new
*close
*eof
*fileno
*print ( ARGS )
*printf ( FMT, [ARGS] )
*getc
*clearerr
*error
*flush
*truncate ( LEN )
*ioctl( FUNCTION, SCALAR )
*ungetc ( ORD )
*autoflush ( [BOOL] )                         $|
*input_line_number( [NUM])                    $.
*sync
*printflush ( ARGS )

fcntl( FUNCTION, SCALAR )
format_write( [FORMAT_NAME] )
read ( BUF, LEN, [OFFSET] )
say ( ARGS )
stat
sysread ( BUF, LEN, [OFFSET] )
syswrite ( BUF, [LEN, [OFFSET]] )

input_record_separator( [STR] )       $/

Furthermore, for doing normal I/O you might need these:

fdopen ( FD, MODE )

getline

getlines


blocking ( [ BOOL ] )

=cut
