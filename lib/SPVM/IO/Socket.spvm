# Copyright (c) 2026 Yuki Kimoto
# MIT License

class IO::Socket extends IO::Handle {
  version_from IO;
  
  use Sys::Socket;
  use Sys::Socket::Constant as SOCKET;
  use Sys::Socket::Sockaddr;
  use Sys::Socket::Sockaddr::In;
  use Sys::Socket::Sockaddr::In6;
  use Sys::Socket::Sockaddr::Un;
  use Sys::Socket::In_addr;
  use Hash;
  use Errno;
  use Go;
  use Sys::Socket::Errno;
  use Fn;
  use Native::MethodCall;
  use Go::Time;
  use Go::Duration_1l;
  use Go::Context::Error::DeadlineExceeded;
  
  # Enumerations
  protected enum {
    SOCKET_CATEGORY_UNKNOWN,
    SOCKET_CATEGORY_CLIENT,
    SOCKET_CATEGORY_SERVER,
    SOCKET_CATEGORY_ACCEPTED,
  }
  
  # Fields
  has SocketCategory : int;
  
  has Domain : protected int;
  
  has Type : protected int;
  
  has Proto : protected int;
  
  has Listen : protected int;
  
  has Timeout : protected double;
  
  has Sockaddr : protected Sys::Socket::Sockaddr;

  # An absolute deadline for I/O operations.
  has Deadline : Go::Time;
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    $self->SUPER::init($options);
    
    my $options = Hash->new($options);
    
    # Domain option
    if ($options->exists("Domain")) {
      $self->{Domain} = $options->get("Domain")->(int);
    }
    
    # Proto option
    if ($options->exists("Proto")) {
      $self->{Proto} = $options->get("Proto")->(int);
    }
    
    # Type option
    if ($options->exists("Type")) {
      $self->{Type} = $options->get("Type")->(int);
    }
    
    # Listen option
    if ($options->exists("Listen")) {
      $self->{Listen} = $options->get("Listen")->(int);
    }
    
    # Timeout option
    if ($options->exists("Timeout")) {
      $self->{Timeout} = $options->get("Timeout")->(double);
    }
    
    # Deadline option
    if ($options->exists("Deadline")) {
      $self->{Deadline} = $options->get("Deadline")->(Go::Time);
    }
    
    # Blocking option
    if ($options->exists("Blocking")) {
      die "Blocking option is not allowed in IO::Socket class and its child classes.";
    }
  }
  
  method option_names : string[] () {
    my $option_names = Array->merge_string(
      $self->SUPER::option_names,
      [
        "Domain",
        "Type",
        "Proto",
        "Listen",
        "Timeout",
        "Deadline",
      ]
    );
    return $option_names;
  }

  # Calculates the remaining duration based on Deadline and Timeout fields.
  private method get_remaining_duration : Go::Duration_1l () {
    my $deadline = $self->{Deadline};
    my $default_timeout_sec = $self->{Timeout};
    my $final_duration : Go::Duration_1l;

    if ($deadline) {
      my $now = Go::Time->now;
      
      # If the deadline has already passed, throw DeadlineExceeded immediately.
      if ($now->after($deadline)) {
        die Go::Context::Error::DeadlineExceeded "The deadline has been exceeded.";
      }
      
      $final_duration = $deadline->sub($now);
      
      if ($final_duration->{nsec} <= 0) {
        die Go::Context::Error::DeadlineExceeded "The deadline has been exceeded.";
      }
      
      if ($default_timeout_sec > 0) {
        my $timeout_duration = Go::Duration_1l->new_from_sec($default_timeout_sec);
        if ($timeout_duration->{nsec} < $final_duration->{nsec}) {
          $final_duration = $timeout_duration;
        }
      }
    }
    elsif ($default_timeout_sec > 0) {
      $final_duration = Go::Duration_1l->new_from_sec($default_timeout_sec);
    }
    return $final_duration;
  }
  
  method timeout : double () {
    return $self->{Timeout};
  }
  
  method set_timeout : void ($timeout : double) {
    $self->{Timeout} = $timeout;
  }
  
  method sockdomain : int () {
    return $self->{Domain};
  }
  
  method socktype : int (){
    return $self->{Type};
  }
  
  method protocol : int () {
    return $self->{Proto};
  }
  
  method shutdown : void ($how : int) {
    my $fd = $self->{FD};
    Sys->shutdown($fd, $how);
  }
  
  method close : void () {
    unless ($self->opened) {
      die "This socket is not opened or already closed.";
    }
    my $fd = $self->{FD};
    Sys::Socket->close($fd);
    $self->{FD} = -1;
  }
  
  method accept : IO::Socket ($peer_ref : Sys::Socket::Sockaddr[] = undef) {
    my $fd = $self->{FD};
    my $client_fd = -1;
    my $client_sockaddr = (Sys::Socket::Sockaddr)undef;
    
    while (1) {
      my $timeout_duration = $self->get_remaining_duration;
      
      eval { $client_sockaddr = Sys->accept(\$client_fd, $fd); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_accept_again(Sys::Socket::Errno->errno);
        if ($again) {
          eval { Go->gosched_io_read($fd, $timeout_duration); }
          # Handle potential timeout from scheduler
          if ($@) {
            if ($@ isa Go::Error::IOTimeout) {
              my $deadline = $self->{Deadline};
              if ($deadline && Go::Time->now->after($deadline)) {
                die Go::Context::Error::DeadlineExceeded "The deadline has been exceeded.";
              }
            }
            die $@;
          }
          next;
        }
        die $@;
      }
      last;
    }
    
    my $options = {
      Timeout => $self->{Timeout},
      Deadline => $self->{Deadline},
      FD => $client_fd,
      Domain => $self->{Domain},
      Type => $self->{Type},
      Proto => $self->{Proto},
    };
    
    my $class = type_name $self;
    my $client = (IO::Socket)Native::MethodCall->call_class_method($class, "new", [(object)$options]);
    if ($peer_ref) { $peer_ref->[0] = $client_sockaddr; }
    return $client;
  }
  
  method recvfrom : int ($buffer : mutable string, $length : int, $flags : int, $from_ref : Sys::Socket::Sockaddr[], $offset : int = 0) {
    unless ($length >= 0) { $length = length $buffer; }
    my $fd = $self->{FD};
    my $recv_length = -1;
    while (1) {
      my $timeout_duration = $self->get_remaining_duration;
      eval { $recv_length = Sys->recvfrom($fd, $buffer, $length, $flags, $from_ref, $offset); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_read_again(Sys::Socket::Errno->errno);
        if ($again) {
          eval { Go->gosched_io_read($fd, $timeout_duration); }
          if ($@) {
            if ($@ isa Go::Error::IOTimeout) {
              my $deadline = $self->{Deadline};
              if ($deadline && Go::Time->now->after($deadline)) {
                die Go::Context::Error::DeadlineExceeded "The deadline has been exceeded.";
              }
            }
            die $@;
          }
          next;
        }
        die $@;
      }
      last;
    }
    return $recv_length;
  }
  
  method sendto : int ($buffer : string, $flags : int, $to : Sys::Socket::Sockaddr, $length : int = -1, $offset : int = 0) {
    unless ($length >= 0) { $length = length $buffer; }
    my $fd = $self->{FD};
    my $send_length = -1;
    while (1) {
      my $timeout_duration = $self->get_remaining_duration;
      eval { $send_length = Sys->sendto($fd, $buffer, $flags, $to, $length, $offset); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_write_again(Sys::Socket::Errno->errno);
        if ($again) {
          eval { Go->gosched_io_write($fd, $timeout_duration); }
          if ($@) {
            if ($@ isa Go::Error::IOTimeout) {
              my $deadline = $self->{Deadline};
              if ($deadline && Go::Time->now->after($deadline)) {
                die Go::Context::Error::DeadlineExceeded "The deadline has been exceeded.";
              }
            }
            die $@;
          }
          next;
        }
        die $@;
      }
      last;
    }
    return $send_length;
  }
  
  method recv : int ($buffer : mutable string, $length : int = -1, $flags : int = 0, $offset : int = 0) {
    return $self->recvfrom($buffer, $length, $flags, (Sys::Socket::Sockaddr[])undef, $offset);
  }
  
  method send : int ($buffer : string, $flags : int = 0, $length : int = -1, $offset : int = 0) {
    return $self->sendto($buffer, $flags, (Sys::Socket::Sockaddr)undef, $length, $offset);
  }
  
  method sysread : int ($buffer : mutable string, $length : int = -1, $offset : int = 0) {
    return $self->recv($buffer, $length, 0, $offset);
  }
  
  method read : int ($buffer : mutable string, $length : int = -1, $offset : int = 0) {
    diag "IO::Socket#read method is deprecated. Use sysread method instead.";
    return $self->recv($buffer, $length, 0, $offset);
  }
  
  method syswrite : int ($buffer : string, $length : int = -1, $offset : int = 0) {
    return $self->send($buffer, 0, $length, $offset);
  }
  
  method write : int ($buffer : string, $length : int = -1, $offset : int = 0) {
    diag "IO::Socket#write method is deprecated. Use syswrite method instead.";
    return $self->send($buffer, 0, $length, $offset);
  }
  
  method sockname : Sys::Socket::Sockaddr () {
    my $fd = $self->{FD};
    return Sys->getsockname($fd);
  }
  
  method peername : Sys::Socket::Sockaddr () {
    my $fd = $self->{FD};
    return Sys->getpeername($fd);
  }
  
  method connected : Sys::Socket::Sockaddr () {
    my $sockaddr = (Sys::Socket::Sockaddr)undef;
    eval { $sockaddr = $self->peername; };
    return $sockaddr;
  }
  
  method atmark : int () {
    my $fd = $self->{FD};
    return Sys::Socket->sockatmark($fd);
  }
  
  method sockopt : string ($level : int, $option_name : int) {
    my $fd = $self->{FD};
    return Sys->getsockopt($fd, $level, $option_name);
  }
  
  method setsockopt : void ($level : int, $option_name : int, $option_value : object of string|Int) {
    my $fd = $self->{FD};
    Sys->setsockopt($fd, $level, $option_name, $option_value);
  }
  
  protected method socket : void () {
    my $domain = $self->{Domain};
    my $type = $self->{Type};
    my $protocol = $self->{Proto};
    my $fd = -1;
    Sys->socket(\$fd, $domain, $type, $protocol);
    $self->{FD} = $fd;
  }
  
  protected method connect : void () {
    my $fd = $self->{FD};
    my $sockaddr = $self->{Sockaddr};
    
    while (1) {
      my $timeout_duration = $self->get_remaining_duration;
      
      eval { Sys->connect($fd, $sockaddr); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_connect_again(Sys::Socket::Errno->errno);
        if ($again) {
          eval { Go->gosched_io_write($fd, $timeout_duration); }
          if ($@) {
            if ($@ isa Go::Error::IOTimeout) {
              my $deadline = $self->{Deadline};
              if ($deadline && Go::Time->now->after($deadline)) {
                die Go::Context::Error::DeadlineExceeded "The deadline has been exceeded.";
              }
            }
            die $@;
          }
          next;
        }
        die $@;
      }
      last;
    }
  }
  
  protected method bind : void () {
    my $sockaddr = $self->{Sockaddr};
    my $fd = $self->{FD};
    Sys->bind($fd, $sockaddr);
  }
  
  protected method listen : void () {
    my $fd = $self->{FD};
    my $listen = $self->{Listen};
    unless ($listen > 0) {
      die "'Listen' field must be greater than 0.";
    }
    Sys->listen($fd, $listen);
  }
  
  method set_blocking : void ($blocking : int) {
    if ($blocking) {
      die "Calling set_blocking method given a true value on an IO::Socket object is forbidden.";
    }
    $self->SUPER::set_blocking($blocking);
  }
  
  method deadline : Go::Time () {
    return $self->{Deadline};
  }

  method set_deadline : void ($deadline : Go::Time) {
    $self->{Deadline} = $deadline;
  }
  
}
