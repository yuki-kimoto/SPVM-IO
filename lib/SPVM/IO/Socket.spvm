# Copyright (c) 2026 Yuki Kimoto
# MIT License

class IO::Socket extends IO::Handle {
  version_from IO;
  
  use Sys::Socket;
  use Sys::Socket::Constant as SOCKET;
  use Sys::Socket::Sockaddr;
  use Sys::Socket::Sockaddr::In;
  use Sys::Socket::Sockaddr::In6;
  use Sys::Socket::Sockaddr::Un;
  use Sys::Socket::In_addr;
  use Hash;
  use Errno;
  use Go;
  use Sys::Socket::Errno;
  use Fn;
  use Native::MethodCall;
  use Go::Time;
  use Go::Duration_1l;
  use Go::Error::IOTimeout;
  
  # Enumerations
  protected enum {
    SOCKET_CATEGORY_UNKNOWN,
    SOCKET_CATEGORY_CLIENT,
    SOCKET_CATEGORY_SERVER,
    SOCKET_CATEGORY_ACCEPTED,
  }
  
  # Fields
  has SocketCategory : int;
  
  has Domain : protected int;
  
  has Type : protected int;
  
  has Proto : protected int;
  
  has Listen : protected int;
  
  has Timeout : protected double;
  
  has Sockaddr : protected Sys::Socket::Sockaddr;

  # An absolute deadline for read operations.
  has ReadDeadline : Go::Time;

  # An absolute deadline for write operations.
  has WriteDeadline : Go::Time;
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    $self->SUPER::init($options);
    
    my $options = Hash->new($options);
    
    # Domain option
    if ($options->exists("Domain")) {
      $self->{Domain} = $options->get("Domain")->(int);
    }
    
    # Proto option
    if ($options->exists("Proto")) {
      $self->{Proto} = $options->get("Proto")->(int);
    }
    
    # Type option
    if ($options->exists("Type")) {
      $self->{Type} = $options->get("Type")->(int);
    }
    
    # Listen option
    if ($options->exists("Listen")) {
      $self->{Listen} = $options->get("Listen")->(int);
    }
    
    # Timeout option
    if ($options->exists("Timeout")) {
      $self->{Timeout} = $options->get("Timeout")->(double);
    }
    
    # ReadDeadline option
    if ($options->exists("ReadDeadline")) {
      $self->{ReadDeadline} = $options->get("ReadDeadline")->(Go::Time);
    }
    
    # WriteDeadline option
    if ($options->exists("WriteDeadline")) {
      $self->{WriteDeadline} = $options->get("WriteDeadline")->(Go::Time);
    }
    
    # Blocking option
    if ($options->exists("Blocking")) {
      die "Blocking option is not allowed in IO::Socket class and its child classes.";
    }
  }
  
  method option_names : string[] () {
    my $option_names = Array->merge_string(
      $self->SUPER::option_names,
      [
        "Domain",
        "Type",
        "Proto",
        "Listen",
        "Timeout",
        "ReadDeadline",
        "WriteDeadline",
      ]
    );
    return $option_names;
  }

  # Calculates the remaining duration based on Deadline and Timeout fields.
  protected method get_remaining_duration : Go::Duration_1l ($is_write : int) {
    my $deadline = $is_write ? $self->{WriteDeadline} : $self->{ReadDeadline};
    
    my $timeout_sec = $self->{Timeout};
    
    unless ($timeout_sec >= 0) {
      die "[Unexpected Error]\$timeout_sec must be non-negative value.";
    }
    
    my $final_duration : Go::Duration_1l;
    
    if ($deadline) {
      my $now = Go::Time->now;
      
      if ($now->after($deadline)) {
        die Go::Error::IOTimeout "The deadline has been exceeded.";
      }
      else {
        if ($timeout_sec == 0) {
          $final_duration = $deadline->sub($now);
        }
        else {
          my $timeout_deadline = $now->add_sec($timeout_sec);
          
          if ($timeout_deadline->after($deadline)) {
            $final_duration = $deadline->sub($now);
          }
          else {
            $final_duration = Go::Duration_1l->new_from_sec($timeout_sec);
          }
        }
      }
      
      unless ($final_duration->{nsec} > 0) {
        die Go::Error::IOTimeout "The deadline has been exceeded.";
      }
    }
    else {
      $final_duration = Go::Duration_1l->new_from_sec($timeout_sec);
    }
    
    return $final_duration;
  }
  
  method timeout : double () {
    return $self->{Timeout};
  }
  
  method set_timeout : void ($timeout : double) {
    $self->{Timeout} = $timeout;
  }
  
  method sockdomain : int () {
    return $self->{Domain};
  }
  
  method socktype : int (){
    return $self->{Type};
  }
  
  method protocol : int () {
    return $self->{Proto};
  }
  
  method shutdown : void ($how : int) {
    my $fd = $self->{FD};
    Sys->shutdown($fd, $how);
  }
  
  method close : void () {
    unless ($self->opened) {
      die "This socket is not opened or already closed.";
    }
    my $fd = $self->{FD};
    Sys::Socket->close($fd);
    $self->{FD} = -1;
  }
  
  method accept : IO::Socket ($peer_ref : Sys::Socket::Sockaddr[] = undef) {
    my $fd = $self->{FD};
    my $client_fd = -1;
    my $client_sockaddr = (Sys::Socket::Sockaddr)undef;
    
    while (1) {
      my $timeout_duration = $self->get_remaining_duration(0);
      
      eval { $client_sockaddr = Sys->accept(\$client_fd, $fd); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_accept_again(Sys::Socket::Errno->errno);
        if ($again) {
          Go->gosched_io_read($fd, $timeout_duration);
          next;
        }
        else {
          die $@;
        }
      }
      last;
    }
    
    my $options = {
      FD => $client_fd,
      Domain => $self->{Domain},
      Type => $self->{Type},
      Proto => $self->{Proto},
    };
    
    my $class = type_name $self;
    my $client = (IO::Socket)Native::MethodCall->call_class_method($class, "new", [(object)$options]);
    if ($peer_ref) { $peer_ref->[0] = $client_sockaddr; }
    
    # Apply default TCP settings to the newly accepted client socket.
    my $domain = $self->{Domain};
    my $type = $self->{Type};
    my $is_internet_tcp_socket
      = ($domain == Sys::Socket::Constant->AF_INET || $domain == Sys::Socket::Constant->AF_INET6)
      && $type == Sys::Socket::Constant->SOCK_STREAM;
    if ($is_internet_tcp_socket) {
      $self->set_default_tcp_settings;
    }
    
    return $client;
  }
  
  method recvfrom : int ($buffer : mutable string, $length : int, $flags : int, $from_ref : Sys::Socket::Sockaddr[], $offset : int = 0) {
    unless ($length >= 0) { $length = length $buffer; }
    my $fd = $self->{FD};
    my $recv_length = -1;
    while (1) {
      my $timeout_duration = $self->get_remaining_duration(0);
      eval { $recv_length = Sys->recvfrom($fd, $buffer, $length, $flags, $from_ref, $offset); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_read_again(Sys::Socket::Errno->errno);
        if ($again) {
          Go->gosched_io_read($fd, $timeout_duration);
          next;
        }
        else {
          die $@;
        }
      }
      last;
    }
    return $recv_length;
  }
  
  method sendto : int ($buffer : string, $flags : int, $to : Sys::Socket::Sockaddr, $length : int = -1, $offset : int = 0) {
    unless ($length >= 0) { $length = length $buffer; }
    my $fd = $self->{FD};
    my $send_length = -1;
    while (1) {
      my $timeout_duration = $self->get_remaining_duration(1);
      eval { $send_length = Sys->sendto($fd, $buffer, $flags, $to, $length, $offset); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_write_again(Sys::Socket::Errno->errno);
        if ($again) {
          Go->gosched_io_write($fd, $timeout_duration);
          next;
        }
        else {
          die $@;
        }
      }
      last;
    }
    return $send_length;
  }
  
  method recv : int ($buffer : mutable string, $length : int = -1, $flags : int = 0, $offset : int = 0) {
    return $self->recvfrom($buffer, $length, $flags, (Sys::Socket::Sockaddr[])undef, $offset);
  }
  
  method send : int ($buffer : string, $flags : int = 0, $length : int = -1, $offset : int = 0) {
    return $self->sendto($buffer, $flags, (Sys::Socket::Sockaddr)undef, $length, $offset);
  }
  
  method sysread : int ($buffer : mutable string, $length : int = -1, $offset : int = 0) {
    return $self->recv($buffer, $length, 0, $offset);
  }
  
  method read : int ($buffer : mutable string, $length : int = -1, $offset : int = 0) {
    diag "IO::Socket#read method is deprecated. Use sysread method instead.";
    return $self->recv($buffer, $length, 0, $offset);
  }
  
  method syswrite : int ($buffer : string, $length : int = -1, $offset : int = 0) {
    return $self->send($buffer, 0, $length, $offset);
  }
  
  method write : int ($buffer : string, $length : int = -1, $offset : int = 0) {
    diag "IO::Socket#write method is deprecated. Use syswrite method instead.";
    return $self->send($buffer, 0, $length, $offset);
  }
  
  method sockname : Sys::Socket::Sockaddr () {
    my $fd = $self->{FD};
    return Sys->getsockname($fd);
  }
  
  method peername : Sys::Socket::Sockaddr () {
    my $fd = $self->{FD};
    return Sys->getpeername($fd);
  }
  
  method connected : Sys::Socket::Sockaddr () {
    my $sockaddr = (Sys::Socket::Sockaddr)undef;
    eval { $sockaddr = $self->peername; };
    return $sockaddr;
  }
  
  method atmark : int () {
    my $fd = $self->{FD};
    return Sys::Socket->sockatmark($fd);
  }
  
  method sockopt : string ($level : int, $option_name : int) {
    my $fd = $self->{FD};
    return Sys->getsockopt($fd, $level, $option_name);
  }
  
  method setsockopt : void ($level : int, $option_name : int, $option_value : object of string|Int) {
    my $fd = $self->{FD};
    Sys->setsockopt($fd, $level, $option_name, $option_value);
  }
  
  protected method socket : void () {
    my $domain = $self->{Domain};
    my $type = $self->{Type};
    my $protocol = $self->{Proto};
    my $fd = -1;
    Sys->socket(\$fd, $domain, $type, $protocol);
    $self->{FD} = $fd;
  }
  
  protected method connect : void () {
    my $fd = $self->{FD};
    my $sockaddr = $self->{Sockaddr};
    
    while (1) {
      my $timeout_duration = $self->get_remaining_duration(1);
      
      eval { Sys->connect($fd, $sockaddr); }
      if ($@) {
        my $again = Sys::Socket::Errno->is_connect_again(Sys::Socket::Errno->errno);
        if ($again) {
          Go->gosched_io_write($fd, $timeout_duration);
          next;
        }
        else {
          die $@;
        }
      }
      last;
    }
  }
  
  protected method bind : void () {
    my $sockaddr = $self->{Sockaddr};
    my $fd = $self->{FD};
    Sys->bind($fd, $sockaddr);
  }
  
  protected method listen : void () {
    my $fd = $self->{FD};
    my $listen = $self->{Listen};
    unless ($listen > 0) {
      die "'Listen' field must be greater than 0.";
    }
    Sys->listen($fd, $listen);
  }
  
  method set_blocking : void ($blocking : int) {
    if ($blocking) {
      die "Calling set_blocking method given a true value on an IO::Socket object is forbidden.";
    }
    $self->SUPER::set_blocking($blocking);
  }
  
  method set_deadline : void ($deadline : Go::Time) {
    $self->{ReadDeadline} = $deadline;
    $self->{WriteDeadline} = $deadline;
  }
  
  method read_deadline : Go::Time () {
    return $self->{ReadDeadline};
  }

  method set_read_deadline : void ($deadline : Go::Time) {
    $self->{ReadDeadline} = $deadline;
  }

  method write_deadline : Go::Time () {
    return $self->{WriteDeadline};
  }

  method set_write_deadline : void ($deadline : Go::Time) {
    $self->{WriteDeadline} = $deadline;
  }
  
  protected method set_default_tcp_settings : void () {
    my $fd = $self->{FD};
    
    # 1. Disable Nagle's algorithm (TCP_NODELAY) as Go does by default.
    my $tcp_nodelay = 1;
    $self->setsockopt(Sys::Socket::Constant->IPPROTO_TCP, Sys::Socket::Constant->TCP_NODELAY, $tcp_nodelay);
    
    # 2. Enable TCP keep-alive with default settings (e.g., 15 seconds)
    # This matches Go's default behavior for net.Dialer.
    my $keepalive_onoff = 1;
    my $keepalive_idle_sec = 15;
    Sys->set_tcp_keepalive($fd, $keepalive_onoff, $keepalive_idle_sec);
  }
  

}
