class IO::Socket extends IO::Handle {
  interface IO::Socket::Interface;
  use Sys::Socket;
  use Sys::Socket::Constant as SOCKET;
  use Sys::Socket::Sockaddr;
  use Sys::Socket::Sockaddr::In;
  use Sys::Socket::Sockaddr::In6;
  use Sys::Socket::Sockaddr::Un;
  use Sys::Socket::In_addr;
  use IO::Select;
  use Hash;
  use IO::Util;
  use Errno;
  use Scope::Guard;

  has fd : ro int;
  has timeout : ro int;
  has sockdomain : ro int;
  has socktype : ro int;
  has protocol : ro int;
  has peername : ro Sys::Socket::Sockaddr;
  has listen_baklog : int;

  method has_interfaces : int () { return 1; }

  static method new : IO::Socket ($options = undef : object[]) {
    
    my $self = new IO::Socket;
    
    $self->init($options);
    
    return $self;
  }
   
  method init : void ($options = undef : object[]) {

    $self->set_autoflush(1);
    
    my $options_h = Hash->new($options);
    
    # Timeout option
    my $timeout = IO::Util->delete_int_or_default($options_h, "Timeout", -1);
    $self->{timeout} = $timeout;
    
    # Domain option
    my $sockdomain = IO::Util->delete_int_or_default($options_h, "Domain", -1);
    $self->{sockdomain} = $sockdomain;
    unless ($sockdomain >= 0) {
      die "The \"Domain\" option must be defined";
    }
    
    # Type option
    my $socktype = IO::Util->delete_int_or_default($options_h, "Type", -1);
    $self->{socktype} = $socktype;
    
    # Blocking option
    my $blocking = IO::Util->delete_int_or_default($options_h, "Blocking", 1);
    $self->set_blocking($blocking);
    
    # Listen option
    my $listen_baklog = IO::Util->delete_int_or_default($options_h, "Listen", 5);
    $self->{listen_baklog} = $listen_baklog;
    
    my $registered_domain = [SOCKET->AF_INET, SOCKET->AF_INET6, SOCKET->AF_UNIX];
    
    for my $key (@{$options_h->keys}) {
      die "The \"$key\" option is not available";
    }
  }

  static method connect : IO::Socket ($host : string, $port : int) {
    
    my $self = new IO::Socket;

    # Socket fd
    my $fd = Sys::Socket->socket(SOCKET->AF_INET, SOCKET->SOCK_STREAM, 0);
    
    $self->{fd} = $fd;
    
    # Socket information
    my $socket_address = Sys::Socket::Sockaddr::In->new;
    $socket_address->set_sin_family((byte)SOCKET->AF_INET);
    $socket_address->set_sin_port(Sys::Socket->htons((short)$port));

    my $res_ref = new Sys::Socket::AddrinfoLinkedList[1];
    Sys::Socket->getaddrinfo($host, undef, undef, $res_ref);
    my $res = $res_ref->[0];
    
    if ($res) {
      my $res_array = $res->to_array;
      $socket_address->set_sin_addr($res_array->[0]->copy_ai_addr->(Sys::Socket::Sockaddr::In)->copy_sin_addr);
    }
    else {
      my $in_addr = Sys::Socket::In_addr->new;
      Sys::Socket->inet_aton($host, $in_addr);
      $socket_address->set_sin_addr($in_addr);
    }
    
    # Connect
    $self->connect_v2($socket_address);
    
    return $self;
  }

  method connect_v2 : int ($address : Sys::Socket::Sockaddr) {
    my $timeout = $self->{timeout};
    
    my $old_blocking = $self->blocking;
    my $restore_blocking_at_end_of_scope : Scope::Guard = undef;
    if ($timeout > 0) {
      $self->set_blocking(0);
      my $this = $self;
      $restore_blocking_at_end_of_scope = Scope::Guard->new([$this : IO::Socket,  $old_blocking : int] method : void () {
        $this->set_blocking($old_blocking);
      });
    }
    
    my $fd = $self->{fd};
    
    my $connect_status = -1;
    eval { $connect_status = Sys::Socket->connect($fd, $address, $address->sizeof); };
    
    my $blocking = $self->blocking;
    if ($blocking) {
      if ($@) {
        die $@;
      }
    }
    else {
      my $errno = Errno->errno;
      if ($errno == Errno->EINPROGRESS || $errno == Errno->EWOULDBLOCK) {
        my $select = IO::Select->new;
        $select->add($fd);
        my $can_write = $select->can_write($timeout);
        
        unless ($can_write) {
          die "connect: timeout";
        }
      }
    }
    
    return $connect_status;
  }
  
  method recv : int ($buffer : mutable string) {
    my $fd = $self->{fd};
    
    my $recv_length = Sys::Socket->recv($fd, $buffer, length $buffer, 0);
    
    return $recv_length;
  }
  
  method send : int ($buffer : string, $length : int) {
    my $fd = $self->{fd};
    
    my $send_length = Sys::Socket->send($fd, $buffer, $length, 0);
    
    return $send_length;
  }
  
  method close : int () {
    my $fd = $self->{fd};
    
    my $status = 0;
    if ($fd >= 0) {
      $status = Sys::Socket->close($fd);
      $self->{fd} = -1;
      $self->{opened} = 0;
    }
    
    return $status;
  }
  
  method fileno : int () { return $self->{fd}; }
  
  method opened : int () {
    my $fd = $self->{fd};
    
    my $opened = 0;
    if ($fd >= 0) {
      $opened = 1;
    }
    
    return $opened;
  }
  
  method DESTROY : void () {
    $self->close;
  }
  
  method listen : int ($queue = 5 : int) {
    my $fd = $self->{fd};
    my $status = Sys::Socket->listen($fd, $queue);
    return $status;
  }

  method sockname : Sys::Socket::Sockaddr () {
    my $fd = $self->{fd};
    my $sockdomain = $self->{sockdomain};
    
    my $addr : Sys::Socket::Sockaddr;
    if ($sockdomain == SOCKET->AF_INET) {
      $addr = Sys::Socket::Sockaddr::In->new;
    }
    elsif ($sockdomain == SOCKET->AF_INET6) {
      $addr = Sys::Socket::Sockaddr::In6->new;
    }
    elsif ($sockdomain == SOCKET->AF_UNIX) {
      $addr = Sys::Socket::Sockaddr::Un->new;
    }
    else {
      die "Unsupported domain";
    }
    
    my $addr_len = $addr->sizeof;
    Sys::Socket->getsockname($fd, $addr, \$addr_len);
    
    return $addr;
  }

  method shutdown : int ($sockfd : int, $how : int) {
    $self->{peername} = undef;
    my $fd = $self->{fd};
    my $status = Sys::Socket->shutdown($fd, $how);
    return $status;
  }


  method atmark : int () {
    my $fd = $self->{fd};
    
    my $status = IO::Util->sockatmark($fd);
    
    return $status;
  }

=pod

  method accept ($sock : int) {
      my $timeout = $self->{timeout};
      
      my $new = IO::Socket->new(Timeout => $timeout);
      my $peer = undef;

      if(defined $timeout) {
        require IO::Select;

        my $sel = IO::Select->new( $sock );

        unless ($sel->can_read($timeout)) {
            $errstr = $@ = 'accept: timeout';
            $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
            return;
        }
      }

      $peer = accept($new,$sock)
        or return;

      ${*$new}{$_} = ${*$sock}{$_} for qw( sockdomain socktype protocol );

      return wantarray ? ($new, $peer)
                     : $new;
  }

  method connected : Sys::Socket::Sockaddr () {
    my $addr : Sys::Socket::Sockaddr = undef;
    eval { $addr = $self->getpeername };
    return $addr;
  }

  method send {
      @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
      my $sock  = $_[0];
      my $flags = $_[2] || 0;
      my $peer;

      if ($_[3]) {
          # the caller explicitly requested a TO, so use it
          # this is non-portable for "connected" UDP sockets
          $peer = $_[3];
      }
      elsif (!defined getpeername($sock)) {
          # we're not connected, so we require a peer from somewhere
          $peer = $sock->peername;

    croak 'send: Cannot determine peer address'
        unless(defined $peer);
      }

      my $r = $peer
        ? send($sock, $_[1], $flags, $peer)
        : send($sock, $_[1], $flags);

      # remember who we send to, if it was successful
      ${*$sock}{'peername'} = $peer
    if(@_ == 4 && defined $r);

      $r;
  }

  method recv {
      @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
      my $sock  = $_[0];
      my $len   = $_[2];
      my $flags = $_[3] || 0;

      # remember who we recv'd from
      ${*$sock}{'peername'} = recv($sock, $_[1]='', $len, $flags);
  }

  method setsockopt {
      @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
      setsockopt($_[0],$_[1],$_[2],$_[3]);
  }

  my $intsize = length(pack("i",0));

  method getsockopt : int[]  {
      @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
      my $r = getsockopt($_[0],$_[1],$_[2]);
      # Just a guess
      $r = unpack("i", $r)
    if(defined $r && length($r) == $intsize);
      $r;
  }

  method sockopt {
      my $sock = shift;
      @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)
        : $sock->setsockopt(SOL_SOCKET,@_);
  }
}

=cut

}
